---
title: "R Notebook"
output: html_notebook
---

```{r}
library(reticulate)
library(laGP)
library(scico)
library(tidyverse)
th <- theme_minimal() + 
  theme(
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "#f7f7f7"),
    panel.border = element_rect(fill = NA, color = "#0c0c0c", size = 0.6),
    axis.text = element_text(size = 11),
    axis.title = element_text(size = 13),
    legend.position = "bottom"
  )
theme_set(th)
```

The block below is needed to install the simulator. In theory, it should be
possible to install using reticulate, but I find it easier to just use the
terminal.

```{sh, eval = FALSE}
conda create -n covid
conda activate covid
conda install numpy=1.21
pip install covasim
pip install sciris
pip install optuna
```

```{r}
use_condaenv("covid", required = TRUE)
```

```{python, message = FALSE}
import covasim as cv

# a few kinds of interventions
testing = cv.test_prob(symp_prob=0.8, asymp_prob=0.001)
tracing = cv.contact_tracing(trace_probs=0.1, trace_time=5.0)
distancing = cv.change_beta(changes=1.0, days=10)
```

This is a calibration example.

```{python, message = FALSE}
import sciris as sc
import covasim as cv

# Create default simulation
pars = sc.objdict(
  pop_size = 1e4,
  start_day = "2020-02-01",
  end_day = "2020-04-11",
  beta = 0.015,
  rel_death_prob = 1.0,
  interventions = cv.test_num(daily_tests="data")
)
sim = cv.Sim(pars=pars, datafile="calibration_data.csv")

# Parameters to calibrate -- format is best, low, high
calib_pars = {
  "beta": [pars.beta, 0.005, 0.20],
  "rel_death_prob": [pars.rel_death_prob, 0.5, 3.0]
}

# Run the calibration
n_trials = 25
n_workers = 4
calib = sim.calibrate(
  calib_pars=calib_pars, 
  n_trials=n_trials, 
  n_workers=n_workers, 
  verbose = 0
)
```

Now we can use these calibration parameters.

```{python}
pars.beta = calib.best_pars["beta"]
pars.rel_death_prob = calib.best_pars["rel_death_prob"]
```

Now that we have a reasonably calibrated model, let's try to learn an emulator
that allows us to see the effect of tracing and testing measures.

```{python, message = FALSE}
import numpy as np

results = []

i = 0
for symp_prob in np.linspace(0.1, .9, 5):
  for trace_prob in np.linspace(.1, .9, 5):
    for trace_time in np.linspace(1, 3, 2):
      testing = cv.test_prob(symp_prob=symp_prob)
      tracing = cv.contact_tracing(trace_probs=trace_prob, trace_time=trace_time)
      pars.interventions = [testing, tracing]
      
      for rep in range(5):
        sim = cv.Sim(pars=pars, verbose = 0)
        sim.run(verbose = 0)
        print(i)
        i += 1
        
        cur_res = sim.to_df()[["t", "new_infections"]]
        cur_res[["symp_prob"]] = symp_prob
        cur_res[["trace_prob"]] = trace_prob
        cur_res[["trace_time"]] = trace_time
        cur_res[["rep"]] = rep
        results.append(cur_res)
```

```{r}
results <- bind_rows(py$results)
ggplot(results) +
  geom_point(
    aes(t, new_infections, col = as.factor(trace_time)),
    alpha = 0.8, size = 0.5
    ) +
  facet_grid(trace_prob ~ symp_prob) +
  scale_color_brewer(palette = "Set2") +
  scale_y_log10()
```

Can we use a surrogate to evaluate the mean number of infections over time for
testing probabilities between those that we directly simulated? We'll focus on
just on of the trace probabilities / time combinations. There's a bit of extra
work here because the package doesn't know how to deal with different GP kernel
scales for different dimensions, so we rescale everything to the 0-1 interval.

```{r, message = FALSE}
xy <- results %>%
  filter(trace_prob == 0.1, trace_time == 1)
x <- xy %>%
  select(t, symp_prob, trace_prob, trace_time)
x_ <- apply(x, 2, function(z) z / max(z))
x_ref <- expand.grid(
  t = seq(0, 1, length.out = 20),
  symp_prob = seq(0, 1, length.out = 20),
  trace_prob = 1,
  trace_time = 1
)

y_hat <- aGP(x_, log(1 + xy$new_infections), x_ref)
```

```{r}
x_ref <- as.matrix(x_ref) %*% diag(apply(x, 2, max))
colnames(x_ref) <- colnames(x)
y_hat_df <- cbind(x_ref, y_hat = y_hat$mean) %>%
  as.data.frame()
```

```{r}
ggplot(y_hat_df) +
  geom_smooth(aes(t, exp(y_hat) - 1, col = symp_prob, group = symp_prob), size = .5, se = F, span = 1) +
  scale_color_scico(palette = "batlow")
```
